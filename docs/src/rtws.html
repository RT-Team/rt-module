<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>rt_module.src.rtws API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>rt_module.src.rtws</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># RT - RTConnection

from __future__ import annotations

from typing import NewType, TypedDict, Literal, Union, Optional, Any
from collections.abc import Iterable, Callable, Coroutine, Sequence

from dataclasses import dataclass

import asyncio

from inspect import iscoroutinefunction
from traceback import format_exc
from secrets import token_hex
from time import time

from websockets import connect, WebSocketServerProtocol, WebSocketClientProtocol
from sanic.server.websockets.impl import WebsocketImplProtocol
from ujson import loads, dumps

from .utils import DataEvent


MainData = Optional[Union[dict[str, Any], list[Any], tuple[Any, ...], str, int, float, Any]]
WebSocket = Union[WebSocketServerProtocol, WebSocketClientProtocol, WebsocketImplProtocol]
Session = NewType(&#34;Session&#34;, str)


@dataclass
class Queues:
    sending: asyncio.Queue
    waiting: dict[Session, DataEvent]


class Packet(TypedDict):
    &#34;通信時にどのようにデータを梱包するかの型です。&#34;
    status: Literal[&#34;Ok&#34;, &#34;Error&#34;]
    type: Literal[&#34;request&#34;, &#34;response&#34;]
    data: Union[Sequence[Sequence[MainData], dict[str, MainData]], str]
    session: Session
    event: str


class RequestError(Exception):
    &#34;リクエストに失敗した際に発生するエラーです。&#34;


EventCoroutine = Coroutine[Any, Any, MainData]
EventFunction = Union[Callable[..., EventCoroutine], Callable[..., MainData]]


class RTWebSocket:
    &#34;サーバーとクライアントと通信を簡単に行うためのものです。&#34;

    ws: Optional[WebSocket] = None
    queues: Optional[Queues] = None

    def __init__(
        self, name: str, *, timeout: float = 10.0, cooldown: float = 0.0001,
        loop: Optional[asyncio.AbstractEventLoop] = None
    ):
        self.name, self.timeout, self.cooldown = name, timeout, cooldown
        self._loop = loop

        self.started = asyncio.Event()
        self.events: dict[str, EventFunction] = {}

        self._successfully_disconnected = None

    def set_event(self, function: EventFunction, name: Optional[str] = None) -&gt; None:
        &#34;イベントを設定します。相手はこれで設定したイベントを呼び出します。そしてこれで設定した関数が返した値を相手に送り返します。&#34;
        awb = iscoroutinefunction(getattr(function, &#34;__func__&#34;, function))
        try: function.__awaitable__ = awb
        except: function.__func__.__awaitable__ = awb
        self.events[name or function.__name__] = function

    def remove_event(self, function_or_name: Union[EventFunction, str]) -&gt; None:
        &#34;イベントを削除します。&#34;
        if not isinstance(function_or_name, str):
            function_or_name = function_or_name.__name__
        del self.events[function_or_name]

    def log(self, mode: str, *args, **kwargs) -&gt; None:
        print(f&#34;[RTWebSocket.{self.name}] [{mode}]&#34;, *args, **kwargs)

    @property
    def loop(self) -&gt; asyncio.AbstractEventLoop:
        &#34;使用しているイベントループを返します。設定されていなければ自動で取得されます。&#34;
        if self._loop is None: self._loop = asyncio.get_running_loop()
        return self._loop

    @loop.setter
    def loop(self, value: asyncio.AbstractEventLoop):
        &#34;使用予定のイベントループを変更します。接続中の場合は設定できません。&#34;
        assert not self.is_ready(), &#34;既にイベントループは使用中のため設定できません。&#34;
        self._loop = value

    async def wait_until_ready(self) -&gt; None:
        &#34;接続するまで待機します。&#34;
        await self.started.wait()

    def is_ready(self) -&gt; bool:
        &#34;準備完了かどうかです。&#34;
        return self.started.is_set()

    def is_connected(self) -&gt; bool:
        &#34;接続をしているかどうかです。&#34;
        return not self.ws.closed

    def make_session(self) -&gt; Session:
        &#34;セッションコードを作成します。&#34;
        return f&#34;RTWS.{self.name}[{time()},{token_hex(8)}]&#34;

    def _packet_repr(self, request: Packet) -&gt; str:
        # リクエストデータをログ等で識別するのに使える状態にします。
        return f&#34;&lt;Packet type={request[&#39;type&#39;]} event={request[&#39;event&#39;]} status={request[&#39;status&#39;]} session={request[&#39;session&#39;]}&gt;&#34;

    def _make_response(self, request: Packet, data: MainData, status: str) -&gt; Packet:
        # レスポンスのデータを作ります。
        return Packet(
            status=status, type=&#34;response&#34;, data=data,
            session=request[&#34;session&#34;], event=request[&#34;event&#34;]
        )

    async def _process_request(self, request: Packet) -&gt; None:
        # リクエストを処理します。
        try:
            assert request[&#34;event&#34;] in self.events, &#34;イベントが見つかりませんでした。&#34;
            data = self.events[request[&#34;event&#34;]](*request[&#34;data&#34;][0], **request[&#34;data&#34;][1])
            if self.events[request[&#34;event&#34;]].__awaitable__:
                data = await data
            data = self._make_response(request, data, &#34;Ok&#34;)
        except Exception:
            self.log(
                &#34;warning&#34;, &#34;An error occurred while processing the request: %s&#34;
                % self._packet_repr(request)
            )
            data = self._make_response(request, format_exc(), &#34;Error&#34;)
        await self.queues.sending.put(data)

    async def _receiver_handler(self) -&gt; None:
        # 受信を行います。
        while self.is_connected():
            data: Packet = loads(await self.ws.recv())
            if data[&#34;type&#34;] == &#34;request&#34;:
                # リクエストの場合は相手からのリクエストを処理する。
                self.log(&#34;info&#34;, &#34;Received request: %s&#34; % self._packet_repr(data))
                self.loop.create_task(
                    self._process_request(data),
                    name=f&#34;RTWebSocket.{self.name}: Process request&#34;
                )
            else:
                # レスポンスの場合はレスポンス待機中のDataEventにレスポンスのデータを設定する。
                self.log(&#34;info&#34;, &#34;Received response: %s&#34; % self._packet_repr(data))
                if data[&#34;session&#34;] in self.queues.waiting:
                    self.queues.waiting[data[&#34;session&#34;]].set(data)

    async def _sender_handler(self) -&gt; None:
        # 送信を行います。
        while self.is_connected():
            try: data: Packet = self.queues.sending.get_nowait()
            except asyncio.QueueEmpty: await asyncio.sleep(self.cooldown)
            else:
                self.log(&#34;info&#34;, &#34;Send packet: %s&#34; % self._packet_repr(data))
                await self.ws.send(dumps(data, ensure_ascii=False))

    async def request(self, event: str, *args, **kwargs) -&gt; MainData:
        &#34;リクエストを行います。相手側であらかじめ登録されているイベントに設定されている関数が返した値が返ります。&#34;
        await self.queues.sending.put(data := Packet(
            status=&#34;Ok&#34;, type=&#34;request&#34;, data=(args, kwargs),
            session=self.make_session(), event=event
        ))
        self.queues.waiting[data[&#34;session&#34;]] = DataEvent()
        try: data: Optional[Packet] = await asyncio.wait_for(
            self.queues.waiting[data[&#34;session&#34;]].wait(), timeout=self.timeout
        )
        except asyncio.TimeoutError: raise RequestError(f&#34;Failed to request: Timeout&#34;)
        if data is None: raise RequestError(f&#34;Failed to request: Disconnected&#34;)
        if data[&#34;status&#34;] == &#34;Error&#34;:
            raise RequestError(f&#34;Failed to request:\n{data[&#39;data&#39;]}&#34;)
        return data[&#34;data&#34;]

    async def communicate(self) -&gt; None:
        &#34;接続をしてバックエンドとの通信を開始します。&#34;
        assert self.ws is not None, &#34;WebSocketが接続されていません。&#34;
        self.clean()
        self.queues = Queues(asyncio.Queue(), {})
        self._disconnect_reason = None
        self.started.set()
        self.receiver_task = self.loop.create_task(
            self._receiver_handler(), name=f&#34;RTWebSocket.{self.name}: Receiver&#34;
        )
        self.sender_task = self.loop.create_task(
            self._sender_handler(), name=f&#34;RTWebSocket.{self.name}: Sender&#34;
        )
        self.log(&#34;info&#34;, &#34;Started connection&#34;)
        done, pending = await asyncio.wait(
            (self.receiver_task, self.sender_task),
            return_when=asyncio.FIRST_COMPLETED,
        )
        for task in done:
            try:
                if task.exception() is not None:
                    self.log(&#34;error&#34;, &#34;Disconnected by error:&#34;, task.exception())
                    self._successfully_disconnected = task.exception()
            except asyncio.InvalidStateError: ...
        for task in pending: task.cancel()
        self.clean()
        self.started.clear()

    async def start(
        self, url: str, *args, reconnect: bool = True,
        okstatus: Iterable[int] = (1000,), **kwargs
    ) -&gt; None:
        &#34;`connect`でWebSocketを用意してから`communicate`を実行します。また、再接続を自動で行います。&#34;
        while 1:
            try: self.ws = await self.connect(url, *args, **kwargs)
            except OSError as e: self.log(&#34;warning&#34;, &#34;Failed to connect to WebSocket: %s&#34; % e)
            else:
                await self.communicate()
                if hasattr(self.ws, &#34;close_code&#34;):
                    if self.ws.close_code in okstatus and self._successfully_disconnected is None:
                        self.log(
                            &#34;info&#34;, &#34;Disconnected successfully: %s %s&#34;
                            % (self.ws.close_code, self.ws.close_reason)
                        )
                        break
                    else:
                        self.log(
                            &#34;error&#34;, &#34;Disconnected due to internal error: %s %s&#34;
                            % (
                                (self.ws.close_code, self.ws.close_reason)
                                if self._successfully_disconnected is None else
                                (self._successfully_disconnected, &#34;&#34;)
                            )
                        )
                else:
                    self.log(&#34;error&#34;, &#34;Disconnected&#34;)
            if reconnect:
                self.log(&#34;info&#34;, &#34;Retry the connection after 3 seconds&#34;)
                await asyncio.sleep(3)
            else: break

    async def connect(self, url: str, *args, **kwargs) -&gt; None:
        &#34;接続を行う関数です。デフォルトではwebsocketsというライブラリを使用します。&#34;
        self.log(&#34;info&#34;, &#34;Connecting...&#34;)
        return await connect(url, *args, **kwargs)

    async def close(self, *args, **kwargs) -&gt; None:
        &#34;WebSocketを閉じます。&#34;
        assert self.ws is not None and self.is_connected(), &#34;まだ接続していません。&#34;
        self.log(&#34;info&#34;, &#34;Closing...&#34;)
        await self.ws.close(*args, **kwargs)
        self.clean()

    def clean(self):
        &#34;残っているWaitingのお片付けをする。&#34;
        if self.queues and self.queues.waiting:
            self.log(&#34;info&#34;, &#34;Cleaning...&#34;)
            for value in list(self.queues.waiting.values()):
                value.set(None)
            self.queues = None

    def __del__(self):
        self.clean()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="rt_module.src.rtws.Packet"><code class="flex name class">
<span>class <span class="ident">Packet</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>通信時にどのようにデータを梱包するかの型です。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Packet(TypedDict):
    &#34;通信時にどのようにデータを梱包するかの型です。&#34;
    status: Literal[&#34;Ok&#34;, &#34;Error&#34;]
    type: Literal[&#34;request&#34;, &#34;response&#34;]
    data: Union[Sequence[Sequence[MainData], dict[str, MainData]], str]
    session: Session
    event: str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="rt_module.src.rtws.Packet.data"><code class="name">var <span class="ident">data</span> : Union[collections.abc.Sequence[collections.abc.Sequence[Union[dict[str, Any], list[Any], tuple[Any, ...], str, int, float, Any, NoneType]], dict[str, Union[dict[str, Any], list[Any], tuple[Any, ...], str, int, float, Any, NoneType]]], str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="rt_module.src.rtws.Packet.event"><code class="name">var <span class="ident">event</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="rt_module.src.rtws.Packet.session"><code class="name">var <span class="ident">session</span> : Session</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="rt_module.src.rtws.Packet.status"><code class="name">var <span class="ident">status</span> : Literal['Ok', 'Error']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="rt_module.src.rtws.Packet.type"><code class="name">var <span class="ident">type</span> : Literal['request', 'response']</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="rt_module.src.rtws.Queues"><code class="flex name class">
<span>class <span class="ident">Queues</span></span>
<span>(</span><span>sending: asyncio.Queue, waiting: dict[Session, DataEvent])</span>
</code></dt>
<dd>
<div class="desc"><p>Queues(sending: 'asyncio.Queue', waiting: 'dict[Session, DataEvent]')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Queues:
    sending: asyncio.Queue
    waiting: dict[Session, DataEvent]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="rt_module.src.rtws.Queues.sending"><code class="name">var <span class="ident">sending</span> : asyncio.queues.Queue</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="rt_module.src.rtws.Queues.waiting"><code class="name">var <span class="ident">waiting</span> : dict</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket"><code class="flex name class">
<span>class <span class="ident">RTWebSocket</span></span>
<span>(</span><span>name: str, *, timeout: float = 10.0, cooldown: float = 0.0001, loop: Optional[asyncio.AbstractEventLoop] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>サーバーとクライアントと通信を簡単に行うためのものです。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RTWebSocket:
    &#34;サーバーとクライアントと通信を簡単に行うためのものです。&#34;

    ws: Optional[WebSocket] = None
    queues: Optional[Queues] = None

    def __init__(
        self, name: str, *, timeout: float = 10.0, cooldown: float = 0.0001,
        loop: Optional[asyncio.AbstractEventLoop] = None
    ):
        self.name, self.timeout, self.cooldown = name, timeout, cooldown
        self._loop = loop

        self.started = asyncio.Event()
        self.events: dict[str, EventFunction] = {}

        self._successfully_disconnected = None

    def set_event(self, function: EventFunction, name: Optional[str] = None) -&gt; None:
        &#34;イベントを設定します。相手はこれで設定したイベントを呼び出します。そしてこれで設定した関数が返した値を相手に送り返します。&#34;
        awb = iscoroutinefunction(getattr(function, &#34;__func__&#34;, function))
        try: function.__awaitable__ = awb
        except: function.__func__.__awaitable__ = awb
        self.events[name or function.__name__] = function

    def remove_event(self, function_or_name: Union[EventFunction, str]) -&gt; None:
        &#34;イベントを削除します。&#34;
        if not isinstance(function_or_name, str):
            function_or_name = function_or_name.__name__
        del self.events[function_or_name]

    def log(self, mode: str, *args, **kwargs) -&gt; None:
        print(f&#34;[RTWebSocket.{self.name}] [{mode}]&#34;, *args, **kwargs)

    @property
    def loop(self) -&gt; asyncio.AbstractEventLoop:
        &#34;使用しているイベントループを返します。設定されていなければ自動で取得されます。&#34;
        if self._loop is None: self._loop = asyncio.get_running_loop()
        return self._loop

    @loop.setter
    def loop(self, value: asyncio.AbstractEventLoop):
        &#34;使用予定のイベントループを変更します。接続中の場合は設定できません。&#34;
        assert not self.is_ready(), &#34;既にイベントループは使用中のため設定できません。&#34;
        self._loop = value

    async def wait_until_ready(self) -&gt; None:
        &#34;接続するまで待機します。&#34;
        await self.started.wait()

    def is_ready(self) -&gt; bool:
        &#34;準備完了かどうかです。&#34;
        return self.started.is_set()

    def is_connected(self) -&gt; bool:
        &#34;接続をしているかどうかです。&#34;
        return not self.ws.closed

    def make_session(self) -&gt; Session:
        &#34;セッションコードを作成します。&#34;
        return f&#34;RTWS.{self.name}[{time()},{token_hex(8)}]&#34;

    def _packet_repr(self, request: Packet) -&gt; str:
        # リクエストデータをログ等で識別するのに使える状態にします。
        return f&#34;&lt;Packet type={request[&#39;type&#39;]} event={request[&#39;event&#39;]} status={request[&#39;status&#39;]} session={request[&#39;session&#39;]}&gt;&#34;

    def _make_response(self, request: Packet, data: MainData, status: str) -&gt; Packet:
        # レスポンスのデータを作ります。
        return Packet(
            status=status, type=&#34;response&#34;, data=data,
            session=request[&#34;session&#34;], event=request[&#34;event&#34;]
        )

    async def _process_request(self, request: Packet) -&gt; None:
        # リクエストを処理します。
        try:
            assert request[&#34;event&#34;] in self.events, &#34;イベントが見つかりませんでした。&#34;
            data = self.events[request[&#34;event&#34;]](*request[&#34;data&#34;][0], **request[&#34;data&#34;][1])
            if self.events[request[&#34;event&#34;]].__awaitable__:
                data = await data
            data = self._make_response(request, data, &#34;Ok&#34;)
        except Exception:
            self.log(
                &#34;warning&#34;, &#34;An error occurred while processing the request: %s&#34;
                % self._packet_repr(request)
            )
            data = self._make_response(request, format_exc(), &#34;Error&#34;)
        await self.queues.sending.put(data)

    async def _receiver_handler(self) -&gt; None:
        # 受信を行います。
        while self.is_connected():
            data: Packet = loads(await self.ws.recv())
            if data[&#34;type&#34;] == &#34;request&#34;:
                # リクエストの場合は相手からのリクエストを処理する。
                self.log(&#34;info&#34;, &#34;Received request: %s&#34; % self._packet_repr(data))
                self.loop.create_task(
                    self._process_request(data),
                    name=f&#34;RTWebSocket.{self.name}: Process request&#34;
                )
            else:
                # レスポンスの場合はレスポンス待機中のDataEventにレスポンスのデータを設定する。
                self.log(&#34;info&#34;, &#34;Received response: %s&#34; % self._packet_repr(data))
                if data[&#34;session&#34;] in self.queues.waiting:
                    self.queues.waiting[data[&#34;session&#34;]].set(data)

    async def _sender_handler(self) -&gt; None:
        # 送信を行います。
        while self.is_connected():
            try: data: Packet = self.queues.sending.get_nowait()
            except asyncio.QueueEmpty: await asyncio.sleep(self.cooldown)
            else:
                self.log(&#34;info&#34;, &#34;Send packet: %s&#34; % self._packet_repr(data))
                await self.ws.send(dumps(data, ensure_ascii=False))

    async def request(self, event: str, *args, **kwargs) -&gt; MainData:
        &#34;リクエストを行います。相手側であらかじめ登録されているイベントに設定されている関数が返した値が返ります。&#34;
        await self.queues.sending.put(data := Packet(
            status=&#34;Ok&#34;, type=&#34;request&#34;, data=(args, kwargs),
            session=self.make_session(), event=event
        ))
        self.queues.waiting[data[&#34;session&#34;]] = DataEvent()
        try: data: Optional[Packet] = await asyncio.wait_for(
            self.queues.waiting[data[&#34;session&#34;]].wait(), timeout=self.timeout
        )
        except asyncio.TimeoutError: raise RequestError(f&#34;Failed to request: Timeout&#34;)
        if data is None: raise RequestError(f&#34;Failed to request: Disconnected&#34;)
        if data[&#34;status&#34;] == &#34;Error&#34;:
            raise RequestError(f&#34;Failed to request:\n{data[&#39;data&#39;]}&#34;)
        return data[&#34;data&#34;]

    async def communicate(self) -&gt; None:
        &#34;接続をしてバックエンドとの通信を開始します。&#34;
        assert self.ws is not None, &#34;WebSocketが接続されていません。&#34;
        self.clean()
        self.queues = Queues(asyncio.Queue(), {})
        self._disconnect_reason = None
        self.started.set()
        self.receiver_task = self.loop.create_task(
            self._receiver_handler(), name=f&#34;RTWebSocket.{self.name}: Receiver&#34;
        )
        self.sender_task = self.loop.create_task(
            self._sender_handler(), name=f&#34;RTWebSocket.{self.name}: Sender&#34;
        )
        self.log(&#34;info&#34;, &#34;Started connection&#34;)
        done, pending = await asyncio.wait(
            (self.receiver_task, self.sender_task),
            return_when=asyncio.FIRST_COMPLETED,
        )
        for task in done:
            try:
                if task.exception() is not None:
                    self.log(&#34;error&#34;, &#34;Disconnected by error:&#34;, task.exception())
                    self._successfully_disconnected = task.exception()
            except asyncio.InvalidStateError: ...
        for task in pending: task.cancel()
        self.clean()
        self.started.clear()

    async def start(
        self, url: str, *args, reconnect: bool = True,
        okstatus: Iterable[int] = (1000,), **kwargs
    ) -&gt; None:
        &#34;`connect`でWebSocketを用意してから`communicate`を実行します。また、再接続を自動で行います。&#34;
        while 1:
            try: self.ws = await self.connect(url, *args, **kwargs)
            except OSError as e: self.log(&#34;warning&#34;, &#34;Failed to connect to WebSocket: %s&#34; % e)
            else:
                await self.communicate()
                if hasattr(self.ws, &#34;close_code&#34;):
                    if self.ws.close_code in okstatus and self._successfully_disconnected is None:
                        self.log(
                            &#34;info&#34;, &#34;Disconnected successfully: %s %s&#34;
                            % (self.ws.close_code, self.ws.close_reason)
                        )
                        break
                    else:
                        self.log(
                            &#34;error&#34;, &#34;Disconnected due to internal error: %s %s&#34;
                            % (
                                (self.ws.close_code, self.ws.close_reason)
                                if self._successfully_disconnected is None else
                                (self._successfully_disconnected, &#34;&#34;)
                            )
                        )
                else:
                    self.log(&#34;error&#34;, &#34;Disconnected&#34;)
            if reconnect:
                self.log(&#34;info&#34;, &#34;Retry the connection after 3 seconds&#34;)
                await asyncio.sleep(3)
            else: break

    async def connect(self, url: str, *args, **kwargs) -&gt; None:
        &#34;接続を行う関数です。デフォルトではwebsocketsというライブラリを使用します。&#34;
        self.log(&#34;info&#34;, &#34;Connecting...&#34;)
        return await connect(url, *args, **kwargs)

    async def close(self, *args, **kwargs) -&gt; None:
        &#34;WebSocketを閉じます。&#34;
        assert self.ws is not None and self.is_connected(), &#34;まだ接続していません。&#34;
        self.log(&#34;info&#34;, &#34;Closing...&#34;)
        await self.ws.close(*args, **kwargs)
        self.clean()

    def clean(self):
        &#34;残っているWaitingのお片付けをする。&#34;
        if self.queues and self.queues.waiting:
            self.log(&#34;info&#34;, &#34;Cleaning...&#34;)
            for value in list(self.queues.waiting.values()):
                value.set(None)
            self.queues = None

    def __del__(self):
        self.clean()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="rt_module.src.rtws.RTWebSocket.queues"><code class="name">var <span class="ident">queues</span> : Optional[<a title="rt_module.src.rtws.Queues" href="#rt_module.src.rtws.Queues">Queues</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket.ws"><code class="name">var <span class="ident">ws</span> : Union[websockets.legacy.server.WebSocketServerProtocol, websockets.legacy.client.WebSocketClientProtocol, sanic.server.websockets.impl.WebsocketImplProtocol, ForwardRef(None)]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="rt_module.src.rtws.RTWebSocket.loop"><code class="name">var <span class="ident">loop</span> : asyncio.events.AbstractEventLoop</code></dt>
<dd>
<div class="desc"><p>使用しているイベントループを返します。設定されていなければ自動で取得されます。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def loop(self) -&gt; asyncio.AbstractEventLoop:
    &#34;使用しているイベントループを返します。設定されていなければ自動で取得されます。&#34;
    if self._loop is None: self._loop = asyncio.get_running_loop()
    return self._loop</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="rt_module.src.rtws.RTWebSocket.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>残っているWaitingのお片付けをする。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self):
    &#34;残っているWaitingのお片付けをする。&#34;
    if self.queues and self.queues.waiting:
        self.log(&#34;info&#34;, &#34;Cleaning...&#34;)
        for value in list(self.queues.waiting.values()):
            value.set(None)
        self.queues = None</code></pre>
</details>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self, *args, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>WebSocketを閉じます。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self, *args, **kwargs) -&gt; None:
    &#34;WebSocketを閉じます。&#34;
    assert self.ws is not None and self.is_connected(), &#34;まだ接続していません。&#34;
    self.log(&#34;info&#34;, &#34;Closing...&#34;)
    await self.ws.close(*args, **kwargs)
    self.clean()</code></pre>
</details>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket.communicate"><code class="name flex">
<span>async def <span class="ident">communicate</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>接続をしてバックエンドとの通信を開始します。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def communicate(self) -&gt; None:
    &#34;接続をしてバックエンドとの通信を開始します。&#34;
    assert self.ws is not None, &#34;WebSocketが接続されていません。&#34;
    self.clean()
    self.queues = Queues(asyncio.Queue(), {})
    self._disconnect_reason = None
    self.started.set()
    self.receiver_task = self.loop.create_task(
        self._receiver_handler(), name=f&#34;RTWebSocket.{self.name}: Receiver&#34;
    )
    self.sender_task = self.loop.create_task(
        self._sender_handler(), name=f&#34;RTWebSocket.{self.name}: Sender&#34;
    )
    self.log(&#34;info&#34;, &#34;Started connection&#34;)
    done, pending = await asyncio.wait(
        (self.receiver_task, self.sender_task),
        return_when=asyncio.FIRST_COMPLETED,
    )
    for task in done:
        try:
            if task.exception() is not None:
                self.log(&#34;error&#34;, &#34;Disconnected by error:&#34;, task.exception())
                self._successfully_disconnected = task.exception()
        except asyncio.InvalidStateError: ...
    for task in pending: task.cancel()
    self.clean()
    self.started.clear()</code></pre>
</details>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self, url: str, *args, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>接続を行う関数です。デフォルトではwebsocketsというライブラリを使用します。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self, url: str, *args, **kwargs) -&gt; None:
    &#34;接続を行う関数です。デフォルトではwebsocketsというライブラリを使用します。&#34;
    self.log(&#34;info&#34;, &#34;Connecting...&#34;)
    return await connect(url, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>接続をしているかどうかです。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self) -&gt; bool:
    &#34;接続をしているかどうかです。&#34;
    return not self.ws.closed</code></pre>
</details>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket.is_ready"><code class="name flex">
<span>def <span class="ident">is_ready</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>準備完了かどうかです。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_ready(self) -&gt; bool:
    &#34;準備完了かどうかです。&#34;
    return self.started.is_set()</code></pre>
</details>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, mode: str, *args, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self, mode: str, *args, **kwargs) -&gt; None:
    print(f&#34;[RTWebSocket.{self.name}] [{mode}]&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket.make_session"><code class="name flex">
<span>def <span class="ident">make_session</span></span>(<span>self) ‑> Session</span>
</code></dt>
<dd>
<div class="desc"><p>セッションコードを作成します。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_session(self) -&gt; Session:
    &#34;セッションコードを作成します。&#34;
    return f&#34;RTWS.{self.name}[{time()},{token_hex(8)}]&#34;</code></pre>
</details>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket.remove_event"><code class="name flex">
<span>def <span class="ident">remove_event</span></span>(<span>self, function_or_name: Union[EventFunction, str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>イベントを削除します。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_event(self, function_or_name: Union[EventFunction, str]) -&gt; None:
    &#34;イベントを削除します。&#34;
    if not isinstance(function_or_name, str):
        function_or_name = function_or_name.__name__
    del self.events[function_or_name]</code></pre>
</details>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket.request"><code class="name flex">
<span>async def <span class="ident">request</span></span>(<span>self, event: str, *args, **kwargs) ‑> Union[dict[str, Any], list[Any], tuple[Any, ...], str, int, float, Any, ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"><p>リクエストを行います。相手側であらかじめ登録されているイベントに設定されている関数が返した値が返ります。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def request(self, event: str, *args, **kwargs) -&gt; MainData:
    &#34;リクエストを行います。相手側であらかじめ登録されているイベントに設定されている関数が返した値が返ります。&#34;
    await self.queues.sending.put(data := Packet(
        status=&#34;Ok&#34;, type=&#34;request&#34;, data=(args, kwargs),
        session=self.make_session(), event=event
    ))
    self.queues.waiting[data[&#34;session&#34;]] = DataEvent()
    try: data: Optional[Packet] = await asyncio.wait_for(
        self.queues.waiting[data[&#34;session&#34;]].wait(), timeout=self.timeout
    )
    except asyncio.TimeoutError: raise RequestError(f&#34;Failed to request: Timeout&#34;)
    if data is None: raise RequestError(f&#34;Failed to request: Disconnected&#34;)
    if data[&#34;status&#34;] == &#34;Error&#34;:
        raise RequestError(f&#34;Failed to request:\n{data[&#39;data&#39;]}&#34;)
    return data[&#34;data&#34;]</code></pre>
</details>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket.set_event"><code class="name flex">
<span>def <span class="ident">set_event</span></span>(<span>self, function: EventFunction, name: Optional[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>イベントを設定します。相手はこれで設定したイベントを呼び出します。そしてこれで設定した関数が返した値を相手に送り返します。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_event(self, function: EventFunction, name: Optional[str] = None) -&gt; None:
    &#34;イベントを設定します。相手はこれで設定したイベントを呼び出します。そしてこれで設定した関数が返した値を相手に送り返します。&#34;
    awb = iscoroutinefunction(getattr(function, &#34;__func__&#34;, function))
    try: function.__awaitable__ = awb
    except: function.__func__.__awaitable__ = awb
    self.events[name or function.__name__] = function</code></pre>
</details>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket.start"><code class="name flex">
<span>async def <span class="ident">start</span></span>(<span>self, url: str, *args, reconnect: bool = True, okstatus: Iterable[int] = (1000,), **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p><code>connect</code>でWebSocketを用意してから<code>communicate</code>を実行します。また、再接続を自動で行います。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start(
    self, url: str, *args, reconnect: bool = True,
    okstatus: Iterable[int] = (1000,), **kwargs
) -&gt; None:
    &#34;`connect`でWebSocketを用意してから`communicate`を実行します。また、再接続を自動で行います。&#34;
    while 1:
        try: self.ws = await self.connect(url, *args, **kwargs)
        except OSError as e: self.log(&#34;warning&#34;, &#34;Failed to connect to WebSocket: %s&#34; % e)
        else:
            await self.communicate()
            if hasattr(self.ws, &#34;close_code&#34;):
                if self.ws.close_code in okstatus and self._successfully_disconnected is None:
                    self.log(
                        &#34;info&#34;, &#34;Disconnected successfully: %s %s&#34;
                        % (self.ws.close_code, self.ws.close_reason)
                    )
                    break
                else:
                    self.log(
                        &#34;error&#34;, &#34;Disconnected due to internal error: %s %s&#34;
                        % (
                            (self.ws.close_code, self.ws.close_reason)
                            if self._successfully_disconnected is None else
                            (self._successfully_disconnected, &#34;&#34;)
                        )
                    )
            else:
                self.log(&#34;error&#34;, &#34;Disconnected&#34;)
        if reconnect:
            self.log(&#34;info&#34;, &#34;Retry the connection after 3 seconds&#34;)
            await asyncio.sleep(3)
        else: break</code></pre>
</details>
</dd>
<dt id="rt_module.src.rtws.RTWebSocket.wait_until_ready"><code class="name flex">
<span>async def <span class="ident">wait_until_ready</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>接続するまで待機します。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_until_ready(self) -&gt; None:
    &#34;接続するまで待機します。&#34;
    await self.started.wait()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="rt_module.src.rtws.RequestError"><code class="flex name class">
<span>class <span class="ident">RequestError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>リクエストに失敗した際に発生するエラーです。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RequestError(Exception):
    &#34;リクエストに失敗した際に発生するエラーです。&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="rt_module.src" href="index.html">rt_module.src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="rt_module.src.rtws.Packet" href="#rt_module.src.rtws.Packet">Packet</a></code></h4>
<ul class="">
<li><code><a title="rt_module.src.rtws.Packet.data" href="#rt_module.src.rtws.Packet.data">data</a></code></li>
<li><code><a title="rt_module.src.rtws.Packet.event" href="#rt_module.src.rtws.Packet.event">event</a></code></li>
<li><code><a title="rt_module.src.rtws.Packet.session" href="#rt_module.src.rtws.Packet.session">session</a></code></li>
<li><code><a title="rt_module.src.rtws.Packet.status" href="#rt_module.src.rtws.Packet.status">status</a></code></li>
<li><code><a title="rt_module.src.rtws.Packet.type" href="#rt_module.src.rtws.Packet.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rt_module.src.rtws.Queues" href="#rt_module.src.rtws.Queues">Queues</a></code></h4>
<ul class="">
<li><code><a title="rt_module.src.rtws.Queues.sending" href="#rt_module.src.rtws.Queues.sending">sending</a></code></li>
<li><code><a title="rt_module.src.rtws.Queues.waiting" href="#rt_module.src.rtws.Queues.waiting">waiting</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rt_module.src.rtws.RTWebSocket" href="#rt_module.src.rtws.RTWebSocket">RTWebSocket</a></code></h4>
<ul class="two-column">
<li><code><a title="rt_module.src.rtws.RTWebSocket.clean" href="#rt_module.src.rtws.RTWebSocket.clean">clean</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.close" href="#rt_module.src.rtws.RTWebSocket.close">close</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.communicate" href="#rt_module.src.rtws.RTWebSocket.communicate">communicate</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.connect" href="#rt_module.src.rtws.RTWebSocket.connect">connect</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.is_connected" href="#rt_module.src.rtws.RTWebSocket.is_connected">is_connected</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.is_ready" href="#rt_module.src.rtws.RTWebSocket.is_ready">is_ready</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.log" href="#rt_module.src.rtws.RTWebSocket.log">log</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.loop" href="#rt_module.src.rtws.RTWebSocket.loop">loop</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.make_session" href="#rt_module.src.rtws.RTWebSocket.make_session">make_session</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.queues" href="#rt_module.src.rtws.RTWebSocket.queues">queues</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.remove_event" href="#rt_module.src.rtws.RTWebSocket.remove_event">remove_event</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.request" href="#rt_module.src.rtws.RTWebSocket.request">request</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.set_event" href="#rt_module.src.rtws.RTWebSocket.set_event">set_event</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.start" href="#rt_module.src.rtws.RTWebSocket.start">start</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.wait_until_ready" href="#rt_module.src.rtws.RTWebSocket.wait_until_ready">wait_until_ready</a></code></li>
<li><code><a title="rt_module.src.rtws.RTWebSocket.ws" href="#rt_module.src.rtws.RTWebSocket.ws">ws</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rt_module.src.rtws.RequestError" href="#rt_module.src.rtws.RequestError">RequestError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>